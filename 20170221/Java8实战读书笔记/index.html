<!DOCTYPE html><html lang="zh-CN"><head><meta name="generator" content="Hexo 3.8.0"><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description"><title>Java8实战读书笔记 | 付啸的个人网站</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/normalize/8.0.1/normalize.min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/1.0.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/1.0.0/grids-responsive-min.css"><link rel="stylesheet" href="//lib.baomitu.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//lib.baomitu.com/jquery/3.3.1/jquery.min.js"></script><link rel="icon" mask="" sizes="any" href="/favicon.ico"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">Java8实战读书笔记</h1><a id="logo" href="/.">付啸的个人网站</a><p class="description">var me = 程序员 &amp;&amp; 吃货</p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">Java8实战读书笔记</h1><div class="post-meta">Feb 21, 2017<span> | </span><span class="category"><a href="/categories/Java/">Java</a></span></div><div class="clear"><div class="toc-article" id="toc"><div class="toc-title">文章目录</div><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#Java8-实战学习笔记"><span class="toc-number">1.</span> <span class="toc-text">Java8 实战学习笔记</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#第二章-通过行为参数化传递代码"><span class="toc-number">1.1.</span> <span class="toc-text">第二章 通过行为参数化传递代码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#第三章-Lambda表达式"><span class="toc-number">1.2.</span> <span class="toc-text">第三章 Lambda表达式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Lambda-使用场景"><span class="toc-number">1.2.1.</span> <span class="toc-text">Lambda 使用场景</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#函数式数据处理"><span class="toc-number">1.2.2.</span> <span class="toc-text">函数式数据处理</span></a></li></ol></li></ol></li></ol></div></div><div class="post-content"><h2 id="Java8-实战学习笔记"><a href="#Java8-实战学习笔记" class="headerlink" title="Java8 实战学习笔记"></a>Java8 实战学习笔记</h2><h3 id="第二章-通过行为参数化传递代码"><a href="#第二章-通过行为参数化传递代码" class="headerlink" title="第二章 通过行为参数化传递代码"></a>第二章 通过行为参数化传递代码</h3><p><code>行为参数化</code> 帮助处理 <em>频繁变更需求</em> 的一种软件开发模式. </p>
<p><code>Predicate</code>: 断言, 陈述. 签名: boolean test()</p>
<h3 id="第三章-Lambda表达式"><a href="#第三章-Lambda表达式" class="headerlink" title="第三章 Lambda表达式"></a>第三章 Lambda表达式</h3><p><code>Lambda表达式</code>: 可以理解为一种匿名函数. 没有名称, 但是有参数列表, 函数主体, 返回类型. 可能还有一个可以抛出异常的异常列表.</p>
<p><code>Lambda表达式</code>可以让你简洁的传递代码.</p>
<p><code>Lambda表达式</code>三部分:</p>
<ul>
<li>参数列表</li>
<li>箭头 -&gt;</li>
<li>lambda主体</li>
</ul>
<table>
<thead>
<tr>
<th style="text-align:left">使用案例</th>
<th style="text-align:left">Lambda示例</th>
<th style="text-align:left">对应函数接口</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">布尔表达式</td>
<td style="text-align:left">(List<string list)="" \-\=""> list.isEmpty()</string></td>
<td style="text-align:left">Predicate&lt;List<string>&gt;</string></td>
</tr>
<tr>
<td style="text-align:left">创建对象</td>
<td style="text-align:left">(&nbsp;&nbsp;) -> new Apple(10)</td>
<td style="text-align:left">Supplier<apple></apple></td>
</tr>
<tr>
<td style="text-align:left">消费一个对象</td>
<td style="text-align:left">(Apple a) -> {<br>&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(a.getWeight()); <br>   }</td>
<td style="text-align:left">Consumer<apple></apple></td>
</tr>
<tr>
<td style="text-align:left">从一个对象中选择/抽取</td>
<td style="text-align:left">(String s) -> s.length()</td>
<td style="text-align:left">Function&lt;String, Integer&gt; 或 ToIntFunction<string></string></td>
</tr>
<tr>
<td style="text-align:left">结合两个值</td>
<td style="text-align:left">(int a, int b) -> a * b</td>
<td style="text-align:left">IntBinaryOparator</td>
</tr>
<tr>
<td style="text-align:left">比较两个对象</td>
<td style="text-align:left">(Apple a1, Apple a2) -> a1.getWeight().compareTo(a2.getWeight())</td>
<td style="text-align:left">BiFunction&lt;Apple, Apple, Integer&gt; 或 ToIntBiFunction&lt;Apple, Apple&gt;</td>
</tr>
</tbody>
</table>
<h4 id="Lambda-使用场景"><a href="#Lambda-使用场景" class="headerlink" title="Lambda 使用场景"></a>Lambda 使用场景</h4><ul>
<li>函数式接口</li>
</ul>
<p><code>函数式接口</code> : 仅仅声明一个抽象方法的接口. </p>
<blockquote>
<p>只有在接受函数式接口的地方才可以使用<code>Lambda</code>表达式.</p>
</blockquote>
<blockquote>
<p>注: Java8+ 接口可以拥有<strong>默认方法</strong>(即在类没有对方法进行实现是, 其主体为方法提供的默认实现的方法), 即使接口内定义了多个默认方法, 但抽象方法只有一个, 则接口仍是一个函数式接口.</p>
</blockquote>
<p><code>@FunctionalInterface</code> 注解用于标注函数式接口, 它不是必须的, 单对于函数式接口的设计, 使用它是最好的做法. 就像<code>@Override</code></p>
<ul>
<li>函数描述符</li>
</ul>
<p><code>函数式接口的抽象方法签名就是Lambda表达式的签名</code>, 我们将这种抽象方法叫<strong>函数描述符</strong></p>
<p><code>函数式描述符</code> : 指函数式接口的抽象方法签名</p>
<p>常用函数式接口:</p>
<table>
<thead>
<tr>
<th style="text-align:left">名称</th>
<th style="text-align:left">签名</th>
<th style="text-align:left">用途</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">Predicate<t></t></td>
<td style="text-align:left">T -> boolean</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">Consumer<t></t></td>
<td style="text-align:left">T -> void</td>
<td style="text-align:left">消费对象</td>
</tr>
<tr>
<td style="text-align:left">Function&lt;T, R&gt;</td>
<td style="text-align:left">T -> R</td>
<td style="text-align:left">提取新的对象/抽取对象某个属性</td>
</tr>
<tr>
<td style="text-align:left">Supplier<t></t></td>
<td style="text-align:left">() -> T</td>
<td style="text-align:left">new 对象</td>
</tr>
<tr>
<td style="text-align:left">UnaryOperator<t></t></td>
<td style="text-align:left">T -> T</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">BinaryOperator<t></t></td>
<td style="text-align:left">( T, T ) -> T</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">BiPredicate&lt;L, R&gt;</td>
<td style="text-align:left">( L, R ) -> boolean</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">BiConsumer&lt;T, U&gt;</td>
<td style="text-align:left">( T, U ) -&gt; void</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">BiFunction&lt;T, U, R&gt;</td>
<td style="text-align:left">( T, U ) -> R</td>
</tr>
</tbody>
</table>
<blockquote>
<p>注为了避免装箱拆箱带来的性能损失, JDK对 <code>Predicate&lt;T&gt;</code> 和 <code>Function&lt;T,R&gt;</code>等通用函数式接口的原始类型特化: <code>IntPredicate</code>, <code>IntToLangFunction</code>等.<br>环绕执行模式( 即在方法所需的代码中间, 你需要执行点什么操作, 比如资源分配和清理)可以配合Lambda提高灵活性和重用性.<br>Lambda表达式所需要代表的类型称之为<code>目标类型</code><br>Comparator, Predicate和Function等函数式接口都有几个可以用来结合Lambda表达式的默认方法.</p>
</blockquote>
<ul>
<li><p>Lambda 的类型是从使用 Lambda 的上下文推断出来的. </p>
<blockquote>
<p>注意: 如果 Lambda 表达式抛出一个异常, 那么抽象方法所声明的 throws 语句也必须与之匹配.</p>
</blockquote>
</li>
<li><p>lambda 使用局部变量的一些限制.</p>
<p>  lambda 函数中调用的局部变量必须声明为<code>final</code>或者事实上是<code>final</code>. </p>
<ol>
<li>实例变量存储在堆中, 而局部变量保存在栈上. Lambda是在一个线程中使用的, 而使用Lambda的线程, 可能会在分配该变量的线程将这个变量收回之后去访问. </li>
<li>这一限制不鼓励你使用改变外部变量的典型命令式编程模式. 他会阻碍很容易做到的并行处理.</li>
</ol>
</li>
<li><p>方法引用</p>
<p>  方法引用让你可以重复使用现有的方法定义, 并像 Lambda 一样传递它们. 它的基本思想是: 如果以个 Lambda 代表的只是 “直接调用这个方法”, 那最好还是用名称调用它, 而不是去描述如何调用它.</p>
<blockquote>
<p>方法引用让你重复使用现有的方法并直接传递它们.</p>
</blockquote>
<p>  你可以把方法引用看做针对仅仅涉及单一方法的Lambda的语法糖.</p>
<p>  方法引用主要有三类:</p>
<ol>
<li>指向<strong>静态方法</strong>的方法引用, 如, <code>Integer</code> 的 <code>parseInt</code> 方法, 写作 <code>Integer::parseInt</code>.</li>
<li>指向<strong>任意类型实例方法</strong>的方法引用, 如 <code>String</code> 的 <code>length</code> 方法, 写作 <code>String::length</code>.</li>
<li><p>指向<code>现有对象的实例方法</code>的方法引用.</p>
<blockquote>
<p>请注意, 还有针对构造函数, 数组构造函数和父类调用(super-call)的一些特殊形式的方法引用.</p>
</blockquote>
</li>
</ol>
</li>
<li><p>构造函数引用</p>
<p>  对于一个现有的构造函数, 可使用: <code>ClassName :: new</code>, 如:</p>
<p>  无参构造函数:</p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Supplier&lt;Apple&gt; c1 = Apple::<span class="keyword">new</span>;</span><br><span class="line"><span class="comment">// 等价于</span></span><br><span class="line">Supplier&lt;Apple&gt; c1 = () -&gt; <span class="keyword">new</span> Apple();</span><br></pre></td></tr></table></figure>
</li>
</ul>
<pre><code>有一个参数的构造函数:

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Function&lt;Integer, Apple&gt; c2 = Apple::<span class="keyword">new</span>;</span><br><span class="line"><span class="comment">// 等价于</span></span><br><span class="line">Function&lt;Integer, Apple&gt; c2 = (weight) -&gt; <span class="keyword">new</span> Apple(weight);</span><br></pre></td></tr></table></figure>


有两个参数的构造函数:

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">BiFunction&lt;String, Integer, Apple&gt; c3 = Apple::<span class="keyword">new</span></span><br><span class="line"><span class="comment">// 等价于</span></span><br><span class="line">BiFunction&lt;String, Integer, Apple&gt; c3 = (color, weight) -&gt; <span class="keyword">new</span> Apple(color, weight);</span><br></pre></td></tr></table></figure>
</code></pre><h4 id="函数式数据处理"><a href="#函数式数据处理" class="headerlink" title="函数式数据处理"></a>函数式数据处理</h4><p>流是Java API的新成员, 它允许你以声明性方式处理数据集合(通过查询语句来表示, 而不是临时编写一个实现). 此外, 流还可以透明地并行处理. </p>
<p><code>流</code>: <strong>从支持数据处理操作的源生成的一系列元素</strong></p>
<ul>
<li>元素序列: 流提供一个接口, 可以访问特定元素类型的一组有序值.</li>
<li><p>源: 流会使用一个提供数据的源. 如集合, 数组,输入/输出资源.</p>
<blockquote>
<p>有序集合生成流时会保留原有的顺序.</p>
</blockquote>
</li>
<li><p>数据处理操作: 流的数据处理功能支持类似数据库的操作, 一级函数式编程语言中的常用操作, 如: filter, map, reduce, find, match, sort等. 流的操作可以顺序执行, 也可以并行执行.</p>
</li>
</ul>
<p>流的特点:</p>
<ul>
<li>流水线: 流水线的操作可以看做对数据源进行数据库式查询.</li>
<li>内部迭代: 迭代通过 <code>filter</code>, <code>map</code>, <code>sorted</code>等中间操作过滤掉了</li>
</ul>
<p>集合和流的差异</p>
<ul>
<li><p>什么时候进行计算. 集合是内存中的数据结构, 它包含数据结构中目前所有的值–集合中的每个元素都是先计算出来才能在添加到集合中的. 流则是概念上固定的数据结构(你不能添加或者删除元素), 其元素是<strong>按需计算</strong>的. 从另一个角度看, 流就像是一个延迟创建的集合; 只有在消费者需要的嘶吼才会计算值. </p>
</li>
<li><p>只能遍历一次. 与迭代器类似, 流只能遍历一次. 遍历完毕, 我们就说这个流已经被消费掉了. 你可以从原始数据源哪里在获取一个新的流并重新遍历一遍. 否则抛出异常: </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java.lang.IllegalStateException: stream has already been operated upon or closed</span><br></pre></td></tr></table></figure>
</li>
<li><p>集合与流的迭代方式不同. 集合使用的外部迭代, 而流使用的内部迭代. </p>
</li>
</ul>
<p>流的操作</p>
<ul>
<li><p>中间操作</p>
<p>  中间操作不会执行任何处理. 中间操作一般可以合并起来, 在终端操作时一次性全部处理.</p>
<ul>
<li>短路</li>
<li>循环合并</li>
</ul>
</li>
<li><p>终端操作</p>
<p>  终端操作会从流的流水线生成结果. </p>
</li>
</ul>
<p>流的使用, 流的使用一般包含三件事:</p>
<ul>
<li>一个数据源(如集合)来进行一个查询</li>
<li>一个中间操作链, 行程也难怪一条流的流水线</li>
<li>一个终端操作, 执行流水线, 并能生成结果</li>
</ul>
<blockquote>
<p>流中的元素是按需计算的.<br>流的迭代操作由外部迭代转向内部迭代.</p>
</blockquote>
<ul>
<li>filter 过滤</li>
<li>distinct 去重</li>
<li>limit 截断 返回给定长度的流</li>
<li>skip 跳过 跳过给定长度的元素 如果元素不足, 则返回void</li>
<li>map 映射 将 T 转为 R </li>
<li><strong>flatMap</strong> 将映射的流合并为一个流, 即扁平化一个流, 即, 将流中的每个值转为另一个流, 然后把所需要的流连接起来成为一个流.</li>
<li><strong>anyMatch</strong> 判断流中是否<em>存在一个元素</em>匹配给定的谓词, <strong>终端操作</strong>, 返回 <em>boolean</em></li>
<li><strong>allMatch</strong> 判断流中是否<em>所有元素</em>匹配给定谓词, <strong>终端操作</strong>, 返回 <em>boolean</em></li>
<li><strong>noneMatch</strong> 与<code>allMatch</code>相反, 确保流中每个元素与谓词都不匹配. <strong>终端操作</strong>, 返回 <em>boolean</em></li>
</ul>
<blockquote>
<p><code>anyMatch</code>, <code>allMatch</code>, <code>noneMatch</code>三个操作都是用到我们所谓的<strong>短路</strong>, 就是Java中的<code>&amp;&amp;</code>和<code>||</code>运算符的短路在流中的版本.<br>短路:指不需要处理完所有表达式, 只需要找到一个表达式为false, 则整个表达式都将返回false.<br>短路对无限大小流非常有用, 可以将无限流变为有限流. </p>
</blockquote>
<ul>
<li><strong>findAny</strong> 返回当前流中任意元素, 与其他流操作结合使用. <strong>终端操作</strong>, 返回<em>Optional<t></t></em></li>
</ul>
<blockquote>
<p><code>Optional&lt;T&gt;</code>类是Java8的容器类. 代表一个值存在或者不存在.<br><code>isPresent()</code>: 包含值时返回 true<br><code>isPresent(Consumer&lt;T&gt; block)</code>: 包含值时执行给定代码块.<br><code>T get()</code>: 值存在时返回值, 否则抛出异常<code>NoSuchElement</code>.<br><code>T orElse(T other)</code>: 值存在时返回值, 否则返回一个默认值(other).</p>
</blockquote>
<ul>
<li><strong>findFirst()</strong> 返回第一个元素. 与其他流操作结合使用. <strong>终端操作</strong>, 返回<em>Optional<t></t></em></li>
</ul>
<blockquote>
<p>何时使用<code>findFirst</code>和<code>findAny</code>? 并行时, <code>findFirst</code>在并行上限制更多, 如果不关心返回元素是那个, 使用<code>findAny</code>, 因为它在使用并行流时限制较少.</p>
</blockquote>
<ul>
<li><strong>reduce</strong> 归约操作. 此操作有两个版本, 包含初始值, 及不包含初始值的, 两个版本的返回值不同, 不包含初始值的返回值为<code>Optional</code>类型. 除了合并结果, 对结果就求最大, 最小值, 数元素个数等等.</li>
</ul>
<blockquote>
<p>流的操作分为<em>有状态</em>和<em>无状态</em>两种. </p>
</blockquote>
<p>数值流</p>
<p>对int等原始类型的, map方法生成的包转类型的流, 存在装箱拆箱成本.</p>
<ul>
<li><p>原始类型特化流: <code>IntStream</code>, <code>DoubleStream</code>, <code>LongStream</code>. 避免了装箱拆箱成本. 且每个接口都带来了进行常用数值归约的新方法. 如: <code>max</code>, <code>sum</code>, <code>min</code>等, 必要时还可以将原始类型特化流转为对象流. </p>
<blockquote>
<p>特化原因: 不在于流的复杂性, 而是装箱造成的复杂性, 即类似<code>int</code>和<code>Integer</code>之间的效率差异.</p>
</blockquote>
</li>
<li><p>映射到数值流: <code>mapToInt</code>, <code>mapToDouble</code>, <code>mapToLong</code></p>
</li>
<li>转回对象流: <code>boxed()</code></li>
<li>默认值<code>OptionalInt</code></li>
</ul>
<p>数值范围</p>
<p>Java8引入了两个用于 <code>IntStream</code> 和 <code>LongStream</code> 的静态方法, 可用于生成数值范围: <code>range</code> 和 <code>rangeClosed</code>. 这两个方法都是: 第一个参数接收起始位置, 第二个参数接收结束位置. 区别在于:<br><code>range</code>方法不包含<em>结束位置</em>, <code>rangeClosed</code>方法包含<em>结束位置</em>.</p>
<p>构建流</p>
<ul>
<li><p>由值创建流</p>
<ul>
<li><code>Stream.of()</code> 显示创建流</li>
</ul>
</li>
<li><p>由数组创建流</p>
<ul>
<li><code>Arrays.stream()</code></li>
</ul>
</li>
<li><p>由文件生成流</p>
<p>  Java 中用于处理文件等 I/O 操作的 NIO API 已更新, 以便利用 Stream API. <code>java.nio.file.Files</code>中很多静态方法都会返回一个流. </p>
</li>
<li><p>由函数生成无限流</p>
<p>  Stream API提供两个静态方法来从函数生成无限流: <code>Stream.iterate</code> 和 <code>Stream.generate</code> 这连个操作可以创建所谓的<strong>无限流</strong>.</p>
<p>  无限流: 不像固定集合创建的流那样有固定大小的流. 由 iterate 和 generate 产生的流会用给定函数按需创建值, 因此可以无穷无尽的计算下去!!!, </p>
<blockquote>
<p>注: 一般来说, 应该使用 <code>limit(N)</code> 来对这种流加以限制, 以避免打印无穷多个值.</p>
</blockquote>
<ul>
<li><p><code>iterate</code> 方法接受一个初始值, 还有一个依次应用在每个产生的新值上的 Lambda函数. </p>
<blockquote>
<p>一般来说: 在需要依次生成一系列值的时候应该使用<code>iterate</code>.</p>
</blockquote>
</li>
<li><p><code>generate</code> 方法不是依次对每个新生成的值应用函数, 它接收一个<code>Supplier&lt;T&gt;</code>类型的Lambda提供的新值.</p>
<p>总结</p>
</li>
<li><p>可使用 <code>filter</code>, <code>distinct</code>, <code>skip</code>, <code>limit</code>对流进行筛选或切片</p>
</li>
<li>可使用 <code>map</code>, <code>flatMap</code>转换流.</li>
<li>可使用 <code>findFirst</code> 和 <code>findAny</code>方法查找流中的元素.</li>
<li><p>可使用 <code>anyMatch</code>, <code>noneMatch</code> 和 <code>allMatch</code> 方法让流匹配给定谓词.</p>
<blockquote>
<p>这些流都利用了短路: 找到结果立即停止计算; 没有必要处理真个流</p>
</blockquote>
</li>
<li><p>可使用 <code>reduce</code> 方法将流中的元素迭代合并成一个结果. 如求和, 最大值等</p>
</li>
<li><code>filter</code> 和 <code>map</code>等操作是无状态的. 他们并不存储任何状态. </li>
<li><code>reduce</code>等操作要存储状态才能计算一个值. <code>sorted</code> 和 <code>distinct</code>等操作也要存储状态, 因为他们需要把流中的所有元素缓存起来才能返回一个新的流. 这种操作也叫做有状态操作. </li>
<li>流由三种基本原始类型特化: <code>IntStream</code>, <code>DoubleStream</code> 和 <code>LongStream</code>. 他们的操作也有相应的特化.</li>
<li>流不仅可以从集合创建, 也可以从值, 数组, 文件以及<code>iterate</code>与<code>generate</code>等特定方法创建.</li>
<li>无限流是没有固定大小的流.</li>
</ul>
</li>
</ul>
<p>用流收集数据</p>
<p>流支持两种操作: <code>中间操作</code> 和 <code>终端操作</code>. 中间操作可以链接起来, 将一个流转为另一个流. 这些操作不会消耗流, 其目的是建立一个流水线. 终端操作会消耗流, 以产生一个最终结果, 如返回一个集合, 一个最大元素.</p>
<p>收集器(Collector)</p>
<p>预定义收集器的三大功能:</p>
<ul>
<li>将流元素归约和汇总为一个值</li>
<li>元素分组</li>
<li><p>元素分区</p>
</li>
<li><p><code>Collectors.counting()</code></p>
</li>
<li><code>Collectors.summingInt()</code></li>
<li><code>Collectors.averagingInt()</code></li>
<li><code>Collectors.summarizingInt()</code>: 通过一次 <code>summarizing</code> 操作你可以得到: 总和, 平均值, 最大值, 最下值.</li>
</ul>
<p>连接字符串</p>
<ul>
<li><code>Collectors.joining()</code></li>
</ul>
<p>收集(collect)和归约(reduce)</p>
<ul>
<li>reduce()方法旨在: 把两个值结合起来生成一个新值, 它是一个不可变的归约. </li>
<li>collect()方法的设计就是要改变容器, 从而累积要输出的结果. </li>
</ul>
<p>分组</p>
<ul>
<li><code>Collectors.groupingBy()</code></li>
<li><code>Collectors.collectingAndThen</code></li>
<li><code>Collectors.mapping()</code></li>
<li><code>Collectors.toCollection()</code></li>
</ul>
<p>分区</p>
<p>分区是分组的特殊情况: 有一个谓词(返回一个布尔值的函数)作为分类函数, 它称之为分区函数. 分区函数返回一个布尔值, 这意味着得到的分组 Map 的键类型是 <code>Boolean</code>, 于是它最多分为两组, <code>true</code>是一组, <code>false</code>是一组. </p>
<ul>
<li><code>Collectors.partitioningBy</code>: 参数需要一个谓词(即: 返回一个布尔值的函数)</li>
</ul>
<p>分区的优势</p>
<p>分区的好处在于: 保留了分区函数返回 <code>true</code> 或 <code>false</code> 的两套流元素列表. </p>
<p><code>Collectors</code> 类的静态工厂方法</p>
<table>
<thead>
<tr>
<th style="text-align:left">工厂方法</th>
<th style="text-align:left">返回类型</th>
<th style="text-align:left">用途</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"></td>
</tr>
</tbody>
</table>
<p><code>toList</code> | <code>List&lt;T&gt;</code> | 把流中的所有项目收集到一个List<br><code>toSet</code> | <code>Set&lt;T&gt;</code> | 把流中的所有项目收集到一个Set, 删除重复项<br><code>toCollection</code> | <code>Collection&lt;T&gt;</code> | 把流中所有项目收集到给定的供应源创建的集合<br><code>counting</code> | <code>Long</code> | 计算流中的元素个数<br><code>summingInt</code> | <code>Integer</code> | 对流中项目的一个整数属性求和<br><code>averagingInt</code> | <code>Double</code> | 对有种项目的一个整数数据求平均值<br><code>summarizingInt</code> | <code>IntSummaryStatistics</code> | 收集关于流中项目<code>Integer</code>属性的统计值, 例如最大, 最小, 总和与平均值.<br><code>joining</code> | <code>String</code> | 连接流中每个元素, 对每个元素调用 <code>toString</code> 方法所生成的字符串进行连接<br><code>maxBy</code> | <code>Optional&lt;T&gt;</code> | 一个包裹了流中按照给定比较器选出最大元素的 <code>Optional</code><br><code>minBy</code> | <code>Optional&lt;T&gt;</code> | 同上求最小值<br><code>reducing</code> | 归约操作产生的类型 | 从一个作为累加器的初始值开始, 利用<code>BinaryOperator</code>与流中的元素逐个结合, 从而将流归约为单个值.<br><code>collectingAndThen</code> | 转换函数返回的类型 | 包含另一个收集器, 对其结果应用转换函数.<br><code>groupingBy</code> | <code>Map&lt;K, List&lt;T&gt;&gt;</code> | 根据项目的一个属性的值对流中的项目作问组, 并将属性值最为结果Map的键<br><code>partitioningBy</code> | <code>Map&lt;Boolean, List&lt;T&gt;&gt;</code> | 根据对流中每个项目应用谓词的结果来对项目进行分区</p>
<p>收集器接口</p>
<p>Collector接口:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Collector</span>&lt;<span class="title">T</span>, <span class="title">A</span>, <span class="title">R</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function">Supplier&lt;A&gt; <span class="title">supplier</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">BiConsumer&lt;A, T&gt; <span class="title">accumulator</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">Function&lt;A, R&gt; <span class="title">finisher</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">BinaryOperator&lt;A&gt; <span class="title">combiner</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">Set&lt;Characteristics&gt; <span class="title">characteristics</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>T 是流中要收集的项目泛型</li>
<li>A 是累加器的类型, 累加器是在收集过程中用于累积部分结果的对象</li>
<li>R 是收集操作得到的对象(通常但并不一定是集合)的类型.</li>
</ul>
<p>前面四个方法都会返回一个会被 <code>collect</code> 方法调用的函数, 而第五个方法 <code>characteristics</code> 则提供了一系列特征, 也就是一个提示列表, 告诉 <code>collect</code> 方法在执行归约操作的时候可以应用那些优化(比如并行化).</p>
<ul>
<li><p>建立新的结果容器: <code>supplier</code> 方法</p>
<p>  <code>supplier</code> 方法必须放回一个结果为空的 <code>Supplier</code>, 也就是一个无参的构造函数, 在调用时它会创建一个空的累加器实例, 提供数据收集过程使用. </p>
</li>
<li><p>将元素添加到结果容器: <code>accumulator</code> 方法</p>
<p>  <code>accumulator</code> 方法会返回执行归约操作的函数. 当遍历到流中第 <code>n</code> 个元素时, 这个函数执行时会有两个参数: 保存归约结果的累加器(已收集了流中前 <code>n-1</code> 个元素), 还有第 <code>n</code> 个元素本身. 该函数将返回 <code>void</code>, 因为累加器是原位更新, 即<em>函数的执行改变了它的内部状态以体现遍历的元素的效果</em>. </p>
</li>
<li><p>对结果容器应用最终转换: <code>finisher</code> 方法</p>
<p>  在遍历完流后, <code>finisher</code> 方法必须返回在累积过程的最后要调用的一个函数, 以便将累加器对象转换为整个集合操作的最终结果. 通常, 累加器对象(<code>accumulator</code> 方法返回)恰好符合预期的最终结果, 因此无需进行转换. 所以 <code>finisher</code> 方法只需返回 <code>Function</code> 接口的静态方法 <code>identity</code> 函数. </p>
</li>
</ul>
<p>以上三个方法已经足以对流进行顺序归约. </p>
<p><img src="https://image.fuxiao86.com/14876400532202.jpg" alt="-w2280"></p>
<ul>
<li><p>合并两个结果容器: <code>combiner</code> 方法</p>
<p>  <code>combiner</code> 方法会返回一个供归约操作使用的函数, 它定义了对流的各个子部分进行并行处理时, 各个子部分归约所得的累加器要如何合并. </p>
<p>  有了这第四个方法, 就可以对流进行并行归约了. 它会用到JAVA7中引入的<em>分支/合并框架</em>和<em>Spliterator</em>抽象. </p>
<p>  <img src="https://image.fuxiao86.com/14876413432867.jpg" alt="-w1209"></p>
</li>
<li><p><code>characteristics</code> 方法</p>
<p>  <code>characteristics</code> 会返回一个不可变的 <code>Characteristics</code> 集合, 它定义了收集器的行为 - 尤其是关于流是否可以并行归约, 以及可以使用那些优化的提示. </p>
<p>  <code>Characteristics</code> 是一个包含三个项目的枚举.</p>
<ul>
<li><code>UNORDERED</code>: 归约结果不受流中项目的遍历和累积顺序的影响.</li>
<li><code>CONCURRENT</code>: <code>accumulator</code>函数可以从多个线程同时调用, 且该收集器可以并行归约流. 如果收集器没有标记为 <code>UNORDERED</code>, 那它仅在用于无序数据源时才可以并行归约. </li>
<li><code>IDENTITY_FINISH</code>: 这表明完成器方法返回的函数是一个恒等函数, 可以跳过. 这种情况下累加器对象将会直接用作归约过程的最终结果. 这也意味着, 将累加器A不加检查地转换为结果R是安全的.</li>
</ul>
</li>
</ul>
<blockquote>
<p><code>Collections.emptyList()</code> 获取一个空的 List</p>
</blockquote>
<p>小结</p>
<ul>
<li><code>collect</code> 是一个终端操作, 它接受的参数时将流中的元素累积到汇总结果的各种方式(称为收集器).</li>
<li>预定义收集器包括: 将流元素归约和汇总到一个值, 例如计算最小值, 最大值或平均值.</li>
<li>预定义收集器可以用<code>groupingBy</code> 对流中元素进行分组, 或用<code>partitioningBy</code>进行分区.</li>
<li>收集器可以高效地复合起来, 进行多级分组, 分区和归约.</li>
<li>可以自定义实现<code>Collector</code> 接口中定义的方法来开发自己的收集器.</li>
</ul>
<p>并行数据处理及性能</p>
<ul>
<li><p>并行流</p>
<p>  并行流: 是一个把内容分成多个数据块, 并且不同的线程分别处理每个数据块的流.</p>
<p>  可以通过对收集源调用<code>parallelStream</code> 方法来把集合转为并行流.</p>
<ul>
<li>对流调用 <code>parallel()</code> 方法可以转为并行流</li>
<li><p>对并行流调用<code>sequential()</code> 方法可以转为顺序流</p>
<p>并行流内部使用了默认的<code>ForkJoinPool</code>, 它默认的线程数量就是运行机器的处理器数量, 这个值是由<code>Runtime.getRuntime().availableProcessors()</code>得到. 但可以通过系统属性: <code>java.util.concurrent.ForkJoinPool.common.parallelism</code> 来改变线程池大小.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System.setProperty(<span class="string">"java.util.concurrent.ForkJoinPool.common.parallelism"</span>, <span class="number">12</span>);</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<pre><code>这是一个全局设置, 因此它将影响代码中所有的并行流. 反过来目前还无法转为某个并行流指定这个值. 一般而言, 让` ForkJoinPool` 的大小等于处理器的数量是个不错的默认值.

&gt; iterate 很难分割成能够独立执行的小块, 因为每次应用这个函数都有依赖前一次应用的结果.

&gt; 共享可变状态会影响并行流以及并行计算. 所以**避免共享可变状态**

高效的使用并行流

* 如果对并行效率有疑问, 请测试运算时间.
* 注意装箱拆箱操作. 自动装箱机拆箱会大大降低性能.
* 有些操作本身在并行流上的性能就比顺序流差. 特别是 `limit` 和 `findFirst` 等依赖于元素顺序的操作. 他们在并行流上执行的代价非常大. `findAny` 会比 `findFirst` 性能好. 可以通过调用 `unordered` 方法来把有序流变成无序流. 对无序并行流调用 `limit` 可能会比单个有序流更高效.
* 并行成本 = N*Q. N: 要处理的元素总数, Q: 一个元素通过流水线的大致处理成本. Q值越高, 意味着并行流性能好的可能性比较大.
* 对于较小的数据量, 选择并行流几乎从来都不是一个好的决定. 并行处理少数几个元素的好处抵不上并行化造成的额外开销.
* 需要考虑流背后的数据结构是否易于分解. 如: AarrayList 的拆分效率比 LinkedList 高的多, 因为前者用不着遍历就可以平均拆分, 而后者必须遍历. 
* 流自身的特点, 以及流水线中的中间操作修改流的方式, 都可能改变分解过程的性能. 
* 还需要考虑终端操作中合并步骤的代价高低. 如 `Collector` 中的 `combiner` 方法.

分支/合并框架

* RecursiveTask&lt;R&gt;/RecursiveAction

    R 是并行化产生的结果类型. 如果任务不返回结果, 则是用 `RecursiveAction`

* Fork/Join 框架的工作窃取技术
* Spliterator 接口.  可分迭代器. 用来遍历数据源中数据, 但它是为了并行执行而设计的. 

    <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Spliterator</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">tryAdvance</span><span class="params">(Consumer&lt;? <span class="keyword">super</span> T&gt; action)</span></span>;</span><br><span class="line">    <span class="function">Spliterator&lt;T&gt; <span class="title">trySplit</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">long</span> <span class="title">estmateSize</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">characteristics</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


    * T 是 Spliterator 遍历的元素的类型
    * tryAdvance 方法的行为类似于普通的 Iterator, 因为它会按顺序一个一个使用 Spliterator 中的元素, 并且如果还有其他元素要遍历就返回 true
    * trySplit 是装为 Spliterator 接口设计的, 因为它可以把一些元素划出去分给第二个 Spliterator( 由该方法返回), 让它们两个并行处理. 
    * Spliterator 通过 estimateSize 方法估计还剩多少元素要遍历
    * characteristics抽象方法, 返回一个 int, 代表Spliterator 本身特性集的编码. 使用 Spliterator 的客户可以使用这些特性来更好地控制和优化它.

    ![-w1422](https://image.fuxiao86.com/14876646717073.jpg)
</code></pre></div><div class="tags"><a href="/tags/Java/">Java</a></div><div class="post-nav"><a class="pre" href="/20170723/new-web/">备案, 重新搭建</a><a class="next" href="/20170101/Docker学习/">Docker学习笔记</a></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><form class="search-form" action="//www.google.com/search" method="get" accept-charset="utf-8" target="_blank"><input type="text" name="q" maxlength="20" placeholder="Search"><input type="hidden" name="sitesearch" value="https://www.fuxiao.im"></form></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Java/">Java</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Nginx/">Nginx</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/docker/">docker</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/杂谈/">杂谈</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/docker/" style="font-size: 15px;">docker</a> <a href="/tags/hexo/" style="font-size: 15px;">hexo</a> <a href="/tags/https/" style="font-size: 15px;">https</a> <a href="/tags/Java/" style="font-size: 15px;">Java</a> <a href="/tags/K8S/" style="font-size: 15px;">K8S</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/20181228/Ubuntu-K8S-1-13-kubeadm搭建集群/">Ubuntu_K8S_1.13_kubeadm搭建集群</a></li><li class="post-list-item"><a class="post-list-link" href="/20181021/CoreOS本地安装/">CoreOS本地VM安装</a></li><li class="post-list-item"><a class="post-list-link" href="/20180815/Golang学习笔记/">Golang学习笔记</a></li><li class="post-list-item"><a class="post-list-link" href="/20180721/蓝鲸CMDB部署个人整理/">蓝鲸CMDB部署个人整理</a></li><li class="post-list-item"><a class="post-list-link" href="/20180610/ElasticSearch学习笔记/">ElasticSearch学习笔记</a></li><li class="post-list-item"><a class="post-list-link" href="/20170723/new-web/">备案, 重新搭建</a></li><li class="post-list-item"><a class="post-list-link" href="/20170221/Java8实战读书笔记/">Java8实战读书笔记</a></li><li class="post-list-item"><a class="post-list-link" href="/20170101/Docker学习/">Docker学习笔记</a></li><li class="post-list-item"><a class="post-list-link" href="/20170101/https/">2017年的第一天, 给自己的网站加个"S"</a></li><li class="post-list-item"><a class="post-list-link" href="/20161018/java8-time/">Better Java (1)- JDK8中有关时间的操作</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> 友情链接</i></div></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2019 <a href="/." rel="nofollow">付啸的个人网站.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//lib.baomitu.com/fancybox/3.5.2/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/fancybox/3.5.2/jquery.fancybox.min.css"><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>